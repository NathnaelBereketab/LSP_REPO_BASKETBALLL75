Question 5 - AI Use in Learning and Problem Solving Reflection

Throughout this Large Scale Programming course, I have strategically used AI tools like ChatGPT and GitHub Copilot to enhance my learning and programming capabilities. Specifically, I utilized AI to clarify complex object-oriented programming concepts such as inheritance hierarchies, interface implementation, and polymorphism when working on assignments. For the ETL pipeline projects, I asked AI for guidance on design patterns and best practices for class cohesion analysis using Arthur Riel's heuristics. During the midterm exam, I consulted AI for specific syntax questions about Java method overloading, exception handling verification, and understanding the differences between inheritance and composition when analyzing the car manufacturer UML structure. The AI was particularly helpful in explaining abstract class implementation and multiple interface implementation patterns for the smart campus device system. I also used AI to verify my understanding of specific programming concepts and get feedback on my code structure and implementation approaches.

The benefits I encountered included faster comprehension of complex programming concepts, immediate feedback on my code structure, and assistance with debugging specific implementation details. However, I also recognized important limitations such as the need to verify AI suggestions against course materials and the importance of understanding underlying principles rather than just copying solutions. Looking ahead, I expect AI to continue influencing my problem-solving approach by serving as a collaborative tool for code review, design pattern exploration, and learning new technologies. I plan to use AI as a supplement to traditional learning methods, ensuring I maintain deep understanding of fundamental concepts while leveraging AI's capabilities for efficiency in implementation and debugging. This balanced approach will be valuable both academically and professionally, allowing me to work more effectively while maintaining strong foundational knowledge in software engineering principles.
