Question 5 - AI Use in Learning and Problem Solving Reflection

Throughout this Large Scale Programming course, I've used AI tools like ChatGPT and GitHub Copilot to help me learn and code better.
I turned to AI whenever I got stuck on tricky object-oriented programming concepts like inheritance hierarchies, interface implementation, 
and polymorphism while working on assignments. For the ETL pipeline projects, I asked AI about design patterns and 
how to analyze class cohesion using Arthur Riel's heuristics. During this midterm exam, I consulted AI for syntax questions
about Java method overloading, double-checking my exception handling, and understanding the differences between inheritance and 
composition when I was analyzing the car manufacturer UML structure. The AI was really helpful in explaining how abstract classes 
work and how to implement multiple interfaces for the smart campus device system. I also used it to verify my understanding and get 
feedback on my code structure. For example, when I was implementing the AreaCalculator class, I asked AI to confirm my circle area 
formula using Math.PI * radius * radius and make sure I was handling exceptions correctly for invalid inputs. When working on the 
smart campus device system, I used AI to figure out how to properly call super(id, location) in constructors and implement multiple
interfaces the right way. I also asked about the exact output formatting for the AreaCalculator demo and why Device should be 
abstract instead of concrete. This collaborative approach with AI helped me work through tough programming challenges faster
while making sure I actually understood the principles behind each solution.

The benefits were that I could grasp complex concepts faster, get immediate feedback on my code structure, and debug implementation 
issues more efficiently. But I also ran into some important limitations. I had to verify AI suggestions against the course materials 
and make sure I wasn't just copying solutions without understanding the underlying principles. For instance, while AI helped me 
understand the syntax for implementing multiple interfaces, I still had to carefully read the requirements myself to make 
sure my DoorLock class correctly implemented both Networked and BatteryPowered interfaces. When working on the cohesion analysis,
AI gave me guidance on Arthur Riel's heuristics, but I had to use my own critical thinking to actually analyze the StudentPortalHelper 
class and come up with my refactoring approach. Looking ahead, I expect AI will keep influencing how I solve problems by serving as 
a tool for code review, exploring design patterns, and learning new technologies. I plan to use AI as a supplement to traditional learning methods,
making sure I maintain a deep understanding of fundamental concepts while using AI's capabilities to be more efficient with implementation and 
debugging. This balanced approach will be valuable both in school and professionally. 
The key is finding the right balance between leveraging what AI can do and maintaining my own critical thinking and problem-solving skills.

