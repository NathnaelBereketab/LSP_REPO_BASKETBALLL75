Question 5 - AI Use in Learning and Problem Solving Reflection

Throughout this Large Scale Programming course, I have strategically used AI tools like ChatGPT and GitHub Copilot to enhance my learning and programming capabilities. 
Specifically, I utilized AI to clarify complex object-oriented programming concepts such as inheritance hierarchies, interface implementation, and polymorphism when working on assignments. 
For the ETL pipeline projects, I asked AI for guidance on design patterns and best practices for class cohesion analysis using Arthur Riel's heuristics. 
During the midterm exam, I consulted AI for specific syntax questions about Java method overloading, exception handling verification, and understanding the differences between inheritance and composition when analyzing the car manufacturer UML structure. 
The AI was particularly helpful in explaining abstract class implementation and multiple interface implementation patterns for the smart campus device system. 
I also used AI to verify my understanding of specific programming concepts and get feedback on my code structure and implementation approaches. 
For example, when implementing the AreaCalculator class, I asked AI to verify my circle area formula using Math.PI * radius * radius and to confirm the proper exception handling for invalid inputs. 
When working on the smart campus device system, I used AI to understand how to properly call super(id, location) in constructors and implement multiple interfaces correctly. 
I also consulted AI for specific questions about the exact output formatting required for the AreaCalculator demonstration and to understand why Device should be abstract rather than concrete. 
This collaborative approach with AI allowed me to work through complex programming challenges more efficiently while ensuring I understood the underlying principles behind each solution.

The benefits I encountered included faster comprehension of complex programming concepts, immediate feedback on my code structure, and assistance with debugging specific implementation details. 
However, I also recognized important limitations such as the need to verify AI suggestions against course materials and the importance of understanding underlying principles rather than just copying solutions. 
For instance, while AI helped me understand the syntax for implementing multiple interfaces, I still needed to carefully read the requirements to ensure my DoorLock class correctly implemented both Networked and BatteryPowered interfaces. 
When working on the cohesion analysis, AI provided guidance on Arthur Riel's heuristics, but I had to apply my own critical thinking to analyze the StudentPortalHelper class and develop my refactoring approach. 
Looking ahead, I expect AI to continue influencing my problem-solving approach by serving as a collaborative tool for code review, design pattern exploration, and learning new technologies. 
I plan to use AI as a supplement to traditional learning methods, ensuring I maintain deep understanding of fundamental concepts while leveraging AI's capabilities for efficiency in implementation and debugging. 
This balanced approach will be valuable both academically and professionally, allowing me to work more effectively while maintaining strong foundational knowledge in software engineering principles. 
The key is finding the right balance between leveraging AI's capabilities and maintaining my own critical thinking and problem-solving skills.