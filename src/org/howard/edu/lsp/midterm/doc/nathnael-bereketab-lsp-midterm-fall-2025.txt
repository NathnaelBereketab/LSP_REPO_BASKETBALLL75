Howard University
College of Engineering and Architecture
Department of Electrical Engineering & Computer Science

Large Scale Programming
Fall 2025


Midterm Exam
October 20, 2025


Instructions
* Exam Format:
Your examination consists of both essay and programming problems.
* Essay Questions:
Complete all essay (rationale) questions inline in this document.
My preference is Microsoft Word (.docx), but .txt or .pdf are acceptable alternatives.
Upload your completed essay file to your repository under the package:
org.howard.edu.lsp.midterm.doc
You may use any file name.
* Programming Problems:
Each programming problem must be uploaded to your repository using the package specified in the question.
For example:
org.howard.edu.lsp.midterm.question1
* Committing Your Work:
If using a third-party IDE or tool to commit, commit early and often.
Do not wait until the end of the exam to push your code.
If you encounter problems committing, you may manually upload your code to your repository.
If you are unable to commit or upload, you may zip your project and email it to
bwoolfolk@whiteboardfederal.com.
?? This will result in a 20% deduction from your final exam score.
* Citations and References:
You must cite all references for any material obtained from the internet.
Any AI-generated content (e.g., ChatGPT conversations) must be included in full.
Each package you upload must include a references document corresponding to that package's content.
?? Failure to provide references will result in a zero for that question.
* Exam Policy:
This is an OPEN BOOK, OPEN NOTES exam.
Collaboration of any kind is strictly prohibited.  Any violations will be handled in accordance with university academic integrity guidelines.


Question 1. (20 pts.)
Given the following, analyze the class below and answer the below questions.  This question does NOT require you to write any code.


package org.howard.edu.lsp.studentPortalHelper;

import java.io.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class StudentPortalHelper {
  // Data cache (in-memory)
  private static final Map<String, String> cache = new HashMap<>();

  // GPA calculation
  public static double computeGPA(List<Integer> grades) {
    if (grades == null || grades.isEmpty()) return 0.0;
    int sum = 0;
    int count = 0;
    for (int g : grades) { sum += g; count++; }
    double avg = (double) sum / count;
    // simple mapping: 90-100=A=4, 80-89=B=3, etc.
    if (avg >= 90) return 4.0;
    if (avg >= 80) return 3.0;
    if (avg >= 70) return 2.0;
    if (avg >= 60) return 1.0;
    return 0.0;
  }

  // CSV export to disk
  public static void exportRosterToCsv(String filename, List<String> names) {
    try (PrintWriter pw = new PrintWriter(new FileWriter(filename))) {
      pw.println("name");
      for (String n : names) {
        pw.println(n);
      }
    } catch (IOException e) {
      System.err.println("Failed to export roster: " + e.getMessage());
    }
  }

  // Email formatting
  public static String makeWelcomeEmail(String studentName) {
    return "Welcome " + studentName + "! Please visit the portal to update your profile.";
  }

  // Date formatting (UI concern)
  public static String formatDateForUi(LocalDate date) {
    return date.format(DateTimeFormatter.ofPattern("MM/dd/yyyy"));
  }

  // Payment processing (stub)
  public static boolean processTuitionPayment(String studentId, double amount) {
    if (amount <= 0) return false;
    // pretend to call external gateway...
    return true;
  }

  // Password strength check (security)
  public static boolean isStrongPassword(String pwd) {
    if (pwd == null || pwd.length() < 8) return false;
    boolean hasDigit = false, hasUpper = false;
    for (char c : pwd.toCharArray()) {
      if (Character.isDigit(c)) hasDigit = true;
      if (Character.isUpperCase(c)) hasUpper = true;
    }
    return hasDigit && hasUpper;
  }

  // Ad-hoc caching
  public static void putCache(String key, String value) {
    cache.put(key, value);
  }

  public static String getCache(String key) {
    return cache.get(key);
  }
}





Tasks:
Using one or more Arthur Riel heuristics, analyze whether the StudentPortalHelper class demonstrates high or low cohesion.
a) Should a well-designed class have high or low cohesion?  Explain and defend your answer.  (5 pts.)


A well-designed class should have high cohesion. High cohesion means that everything inside a class—its methods and data—works
together toward one clear purpose. According to Arthur Riel's heuristics, especially the idea that "a class should capture one and only one key abstraction,"
high cohesion makes classes much easier to understand, maintain, test, and reuse. When a class has high cohesion,
making changes to one part of the system won't force you to modify a bunch of unrelated code elsewhere. 
On the flip side, low cohesion is a red flag that a class is juggling too many unrelated responsibilities, which breaks the Single Responsibility Principle and makes the code messier and more bug-prone.

b) Based on your analysis, discuss-only if you believe changes are needed-how you would reorganize or redesign the class to improve its structure. Your answer should (1) identify the class as having high, low or perfect cohesion and (2) describe a general approach to refactoring the class.  If you believe the class already has good cohesion, justify why no changes are necessary. (15 pts)
(If you believe the class already has good cohesion, justify why no changes are necessary.)

The StudentPortalHelper class demonstrates low cohesion. Looking at Arthur Riel's heuristics, particularly "a class should capture one 
and only one key abstraction" and "most methods should be using most of the data members most of the time," it's clear
this class breaks both rules. The class is trying to do way too much at once—it handles academic calculations like GPA computation, 
file operations for CSV exports, email formatting for welcome messages, UI date formatting, payment processing for tuition, 
password security checks, and even some basic caching. These methods don't share any common data (except for the cache, which only two methods actually use),
and they all serve completely different purposes. This is a textbook "utility class" or "God class" that's become a 
catch-all for random functionality that didn't have anywhere else to go.

To fix this, I'd break this single class into several smaller, focused classes, each with one clear job. 
First, I'd create a GradeCalculator class to handle anything related to GPA and grade calculations. 
Second, a RosterExporter would take care of CSV exports and file operations for student rosters. 
Third, an EmailService would handle all the email formatting and message generation. Fourth, a DateFormatter would manage date formatting for the UI.
Fifth, a PaymentProcessor would deal with tuition payments. Sixth, a PasswordValidator would
handle password strength checks and other security validations. Finally, a CacheManager would provide proper 
caching with all the standard operations instead of just two basic methods. Each of these new classes would have high
cohesion because everything inside would work together toward one goal. For instance, the GradeCalculator could
eventually grow to include semester GPA, cumulative GPA, grade distributions, and other academic metrics—all 
related to student performance. The CacheManager could become a real caching solution with put, get, clear, size, 
and other standard cache operations instead of the bare-bones setup we have now. This refactoring would make 
the code much easier to maintain, test, and extend since each class would have one clear responsibility and everything inside would actually belong together.

Question 2. (20 pts.)

Write a class AreaCalculator in the package org.howard.edu.lsp.midterm.question2 with the following overloaded methods:  This should be uploaded to your repo.

// Circle area
public static double area(double radius)

// Rectangle area
public static double area(double width, double height)

// Triangle (base & height) area
public static double area(int base, int height)

// Square (side length) area
public static double area(int side)

Requirements:
Each method should compute and return the correct area.
* Circle area: p (use class Math.PI) � r�
* Rectangle area: width � height
* Triangle area: 1/2 � base � height
* Square area: side�
* For all methods: throw an IllegalArgumentException if any dimension is = 0.

Create a class named Main that invokes each overloaded method statically to produce exactly the following output:

Circle radius 3.0 ? area = 28.274333882308138
Rectangle 5.0 x 2.0 ? area = 10.0
Triangle base 10, height 6 ? area = 30.0
Square side 4 ? area = 16.0

Finally, invoke at least one of the area methods with a value that causes an IllegalArgumentException to be thrown.
* Catch the exception using a try/catch block.
* Print an error message to System.out. (Any message is fine.)
Briefly (2-3 sentences as a comment in class Main) explain if overloading or simply use methods with different names, i.e., rectactangleArea, circleArea, etc.. 


Category
Description
Points
1. Implementation
Correct use of method overloading (same name, different signatures), correct formulas, and proper exception handling in each method.
10
2. Program Behavior
Main correctly invokes all methods statically, produces the required output exactly, and includes a working exception demonstration.
6
3. Conceptual Understanding
Brief explanation of why or why not overloading is the better design choice.
4


Question 3. 
Given the following, answer the below questions.
(20 pts.)
        
Given:    
A car manufacturer uses Java software to track current vehicles being built. The UML diagram below shows an excerpt of the current software structure. You should assume the presence of other appropriate fields and methods



Each car can be built to one of three trim levels: Base, Luxury or Sport. They can also be configured with an electric or petrol engine. At various points in the manufacturing process the customer can choose to change the trim level. 

Task:
a) Explain in detail why the current structure does or does not support this. (10 pts.)

The current structure does not support dynamic trim-level changes during the manufacturing process.
This design uses class inheritance to represent trim levels (Base, Sports, Luxury), which locks in the trim
level at compile-time when you create a car object as a specific subclass (like new Sports() or new Luxury()).
Once you've created a car as a particular trim class, that's it—its type is fixed and can't be changed at runtime.
If a customer decides mid-manufacturing that they want to upgrade from Base to Luxury, 
the system would have to create a completely new Luxury object and copy over all the information from the old Base object.
This is messy, error-prone, and completely defeats the point of tracking one vehicle through its entire manufacturing journey.

The inheritance hierarchy makes things even more rigid. The trim level is baked into the class identity
itself through the "is-a" relationship—a Base car "is-a" Car, and it will always be a Base car. 
Java doesn't let you change an object's class at runtime, so there's no way to turn a Base instance 
into a Sports or Luxury instance without creating a whole new object. This breaks the basic principle 
that you should be able to change behavior without changing identity.
Even worse, if the system needs to handle engine type changes too (Electric vs Petrol), 
the parallel inheritance hierarchies would explode into a nightmare. You'd need
separate classes for every possible combination—BaseElectric, BasePetrol, SportsElectric, 
SportsPetrol, LuxuryElectric, LuxuryPetrol—making the design impossible to maintain and violating the Open/Closed Principle.

b) Describe how to refactor the structure to allow trim-level change for a car to dynamically change.  Hint: How would you modify Car to use composition to solve the problem? (10 pts.)

To refactor this structure and support dynamic trim-level changes, I would replace the inheritance-based approach 
with a composition-based design using the Strategy pattern. Instead of making Base, Sports, and Luxury subclasses 
of Car, I'd create a TrimLevel interface (or abstract class) that defines what trim levels can 
do—things like getFeatures(), getPrice(), and other trim-specific operations. Then I'd make concrete 
implementations: BaseTrim, SportsTrim, and LuxuryTrim. The Car class would have a private TrimLevel 
instance variable (like private TrimLevel trimLevel;) and a setter method setTrimLevel(TrimLevel newTrim) 
that lets you swap out the trim level whenever you want at runtime.

I'd do the same thing for engine types. Create an Engine interface with concrete implementations 
like ElectricEngine and PetrolEngine, and give the Car class a private Engine instance variable with its 
own setter method. The Car class would then hand off trim-specific and engine-specific behavior to these 
composed objects. For example, if you call getTrimLevel() on a Car, it might just return trimLevel.getName(),
and any engine-related methods would delegate to the engine object. This composition approach follows the 
classic principle of "favor composition over inheritance" and gives you the flexibility to change both trim
level and engine type on the fly during manufacturing. When a customer wants to upgrade their trim, 
the system just calls car.setTrimLevel(new LuxuryTrim())—no need to create a new Car object. The
car keeps its identity and all its other information intact throughout the whole manufacturing process. 
This design is way more maintainable and extensible, and it follows SOLID principles, especially 
the Open/Closed Principle, since you can add new trim levels or engine types without touching any existing code.

Question 4. (30 pts.)

Design and implement a small smart-campus device system showing both class inheritance (concrete classes extend a common abstract class) and interface implementation.

1) Abstract Base Class - Device
The following Device class is partially implemented for you.
You must not modify this code, but you will use it in your subclasses:

package org.howard.edu.lsp.midterm.question4;

public abstract class Device {
  private String id;
  private String location;
  private long lastHeartbeatEpochSeconds;
  private boolean connected;

  // PROVIDED CONSTRUCTOR
  public Device(String id, String location) {
    if (id == null || id.isEmpty() || location == null || location.isEmpty()) {
      throw new IllegalArgumentException("Invalid id or location");
    }
    this.id = id;
    this.location = location;
    this.lastHeartbeatEpochSeconds = 0;
    this.connected = false;
  }

  public String getId() {
    return id;
  }

  public String getLocation() {
    return location;
  }



  public long getLastHeartbeatEpochSeconds() {
    return lastHeartbeatEpochSeconds;
  }

  public boolean isConnected() {
    return connected;
  }

  protected void setConnected(boolean connected) {
    this.connected = connected;
  }

  public void heartbeat() {
    this.lastHeartbeatEpochSeconds = System.currentTimeMillis() / 1000;
  }

  public abstract String getStatus();
}

You will extend this class in your DoorLock, Thermostat, and Camera implementations.
All subclasses must call super(id, location) in their constructors.

2) Capability Interfaces (behaviors only)
Networked

void connect();
void disconnect();
boolean isConnected();

Behavior:
* connect() brings the device online by setting connected = true.
* disconnect() sets connected = false.
* isConnected() reports the current connection state.
(Concrete classes may satisfy this using Device's protected setter and public getter.)

BatteryPowered

int getBatteryPercent();      // 0..100
void setBatteryPercent(int percent);

Behavior:
* getBatteryPercent() returns current battery %.
* setBatteryPercent(int) updates it; throw IllegalArgumentException if outside 0..100 inclusive.

3) Concrete Devices (must extend Device and implement interfaces)
All fields must be private. Implement methods exactly as specified.

A) DoorLock - extends Device, implements Networked, BatteryPowered
Private fields

private int batteryPercent;

Constructor
public DoorLock(String id, String location, int initialBattery)

* Call super(id, location).
* Initialize battery by calling setBatteryPercent(initialBattery) (enforces 0..100).


Implemented methods

// Networked
@Override public void connect()    { setConnected(true);  }
@Override public void disconnect() { setConnected(false); }
@Override public boolean isConnected() { return super.isConnected(); }

// BatteryPowered
@Override public int getBatteryPercent() { return batteryPercent; }
@Override public void setBatteryPercent(int percent) {
  if (percent < 0 || percent > 100) throw new IllegalArgumentException("battery 0..100");
  this.batteryPercent = percent;
}

// Status
@Override public String getStatus() {
  String connStatus = isConnected() ? "up" : "down";
  return "DoorLock[id=" + getId() + ", loc=" + getLocation() +
         ", conn=" + connStatus + ", batt=" + batteryPercent + "%]";
}

B) Thermostat - extends Device, implements Networked
Private fields

private double temperatureC;

Constructor
public Thermostat(String id, String location, double initialTempC)

* Call super(id, location).
* Initialize temperatureC to initialTempC.

Accessors

public double getTemperatureC();
public void setTemperatureC(double temperatureC);

Implemented methods

// Networked
@Override public void connect()    { setConnected(true);  }
@Override public void disconnect() { setConnected(false); }
@Override public boolean isConnected() { return super.isConnected(); }

// Status
@Override public String getStatus() {
  String connStatus = isConnected() ? "up" : "down";
  return "Thermostat[id=" + getId() + ", loc=" + getLocation() +
         ", conn=" + connStatus + ", tempC=" + temperatureC + "]";
}

C) Camera - extends Device, implements Networked, BatteryPowered

Private fields
private int batteryPercent;

Constructor

public Camera(String id, String location, int initialBattery)

* Call super(id, location).
* Initialize battery by calling setBatteryPercent(initialBattery).




Implemented methods

// Networked
@Override public void connect()    { setConnected(true);  }
@Override public void disconnect() { setConnected(false); }
@Override public boolean isConnected() { return super.isConnected(); }

// BatteryPowered
@Override public int getBatteryPercent() { return batteryPercent; }
@Override public void setBatteryPercent(int percent) {
  if (percent < 0 || percent > 100) throw new IllegalArgumentException("battery 0..100");
  this.batteryPercent = percent;
}

// Status
@Override public String getStatus() {
  String connStatus = isConnected() ? "up" : "down";
  return "Camera[id=" + getId() + ", loc=" + getLocation() +
         ", conn=" + connStatus + ", batt=" + batteryPercent + "%]";
}

4) Provided Driver

Do not modify this file. Your classes must compile and run with it unchanged.


package org.howard.edu.lsp.midterm.question4;

import java.util.*;

public class Main {
  public static void main(String[] args) {
    Device lock   = new DoorLock("DL-101", "DormA-1F", 85);
    Device thermo = new Thermostat("TH-202", "Library-2F", 21.5);
    Device cam    = new Camera("CA-303", "Quad-North", 72);

    // === Invalid battery test ===
    System.out.println("\n== Exception test ==");
    try {
      Device badCam = new Camera("CA-404", "Test-Lab", -5);
      System.out.println("ERROR: Exception was not thrown for invalid battery!");
    } catch (IllegalArgumentException e) {
      System.out.println("Caught expected exception: " + e.getMessage());
    }

    // === Heartbeat demonstration ===
    System.out.println("\n== Heartbeat timestamps BEFORE ==");
    for (Device d : Arrays.asList(lock, thermo, cam)) {
      System.out.println(d.getId() + " lastHeartbeat=" + d.getLastHeartbeatEpochSeconds());
    }

    lock.heartbeat();
    thermo.heartbeat();
    cam.heartbeat();

    System.out.println("\n== Heartbeat timestamps AFTER ==");
    for (Device d : Arrays.asList(lock, thermo, cam)) {
      System.out.println(d.getId() + " lastHeartbeat=" + d.getLastHeartbeatEpochSeconds());
    }

    // === Base-class polymorphism ===
    List<Device> devices = Arrays.asList(lock, thermo, cam);
    System.out.println("\n== Initial status via Device ==");
    for (Device d : devices) {
      System.out.println(d.getStatus());
    }

    // === Interface polymorphism: Networked ===
    System.out.println("\n== Connect all Networked ==");
    for (Device d : devices) {
      if (d instanceof Networked) {
        ((Networked) d).connect();
      }
    }

    // === Interface polymorphism: BatteryPowered ===
    System.out.println("\n== Battery report (BatteryPowered) ==");
    for (Device d : devices) {
      if (d instanceof BatteryPowered) {
        BatteryPowered bp = (BatteryPowered) d;
        System.out.println(d.getClass().getSimpleName() + " battery = " + bp.getBatteryPercent() + "%");
      }
    }

    // === Final status check ===
    System.out.println("\n== Updated status via Device ==");
    for (Device d : devices) {
      System.out.println(d.getStatus());
    }
  }
}

5) Brief Rationale (2-4 sentences)  (Also solved in Rationale.txt)


* Why is Device defined as an abstract class? 

Device is defined as an abstract class because it provides the common
functionality that all smart campus devices need—things like id, location, 
heartbeat, and connection status—while still requiring each concrete device 
to implement its own specific getStatus() method. This follows the template 
method pattern where you define the shared behavior in the abstract class but 
leave the device-specific details to the subclasses.Retry

* How do the Networked and BatteryPowered interfaces add behavior to your concrete classes?

The Networked and BatteryPowered interfaces add specific capabilities to 
devices by letting them implement whichever interfaces they actually need.
Networked devices can connect, disconnect, and report their connection status, 
while BatteryPowered devices can track and manage their battery levels. 
This gives you flexible composition where different devices can mix and match capabilities—DoorLock and Camera have both, but Thermostat only needs Networked since it's plugged into the wall.

* Is this design an example of multiple inheritance in Java? Explain why or why not.

No, this is not multiple inheritance. Java only lets you extend one class 
at a time (Device is the only parent class here), but you can implement as
many interfaces as you want. The concrete classes extend one abstract class
(Device) and then implement multiple interfaces (Networked, BatteryPowered).
This is interface-based composition, not multiple inheritance, which gives you flexible behavior without all the messy complications that come with true multiple inheritance.


Grading (30 pts)


Category
Description
Points
Implementation
Correct use of inheritance and interfaces; meets all required method signatures and behaviors; uses the provided Device constructor; correctly implements Networked and BatteryPowered; uses setConnected(boolean) properly; validates inputs.
15
Program Behavior
Code compiles and runs with the provided Main.java unchanged; heartbeat behavior works; base-class and interface polymorphism demonstrated; exception thrown for invalid battery input; getStatus() output matches required formats.
9
Rationale
Clear, thoughtful, and specific answers to the four questions above. References to the student's own code are present. Shows conceptual understanding of abstraction, interface-based behavior, and multiple inheritance in Java.
6


Question 5 (10 pts)
Reflection on AI Use in Learning and Problem Solving
Discuss your personal experience using AI tools (such as ChatGPT, GitHub Copilot, or others) before and during this course.
In your response, address the following points:
1. How have you used AI to support your learning or programming in this course?
2. What benefits or limitations did you encounter?
3. Looking ahead, how do you expect AI to influence the way you solve problems academically or professionally?
Your answer should be 1-2 well-developed paragraphs.

Solved under Question 5 folder.




































